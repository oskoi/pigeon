// Package builder generates the parser code for a given grammar. It makes
// no attempt to verify the correctness of the grammar.
package builder

import (
	"bytes"
	"fmt"
	"io"
	"regexp"
	"strconv"
	"strings"
	"text/template"
	"unicode"

	"github.com/fy0/pigeon/ast"
)

type ExprInfo struct {
	Index    int
	Name     string
	ExprType string
}

const codeGeneratedComment = "// Code generated by pigeon; DO NOT EDIT.\n\n"

func (b *Builder) TemplateRenderBase(text string, trim bool, m map[string]any) string {
	t, err := template.New("").Parse(text)

	var out bytes.Buffer
	err = t.Execute(&out, m)

	if err != nil {
		panic(err)
	}

	if trim {
		return strings.TrimSpace(out.String())
	} else {
		return out.String()
	}
}

func (b *Builder) TemplateRender(text string, trim bool) string {
	return b.TemplateRenderBase(text, trim, map[string]any{
		"Target":      b.Target,
		"GrammarOnly": b.GrammarOnly,
	})
}

// generated function templates
var (
	callCodeFuncTemplate = `func (p *parser) call{{.FuncName}}() any {
{{ if .useStack }} stack := p.vstack[len(p.vstack)-1]; {{ end }} return (func (c *current, {{.paramsDef}}) any {
		{{.code}}
		return nil
	})(&p.cur, {{.paramsCall}})
}
`
	callPredFuncTemplate = `func (p *parser) call{{.FuncName}}() bool {
{{ if .useStack }} stack := p.vstack[len(p.vstack)-1]; {{ end }}	return (func (c *current, {{.paramsDef}}) bool {
		{{.code}}
	})(&p.cur, {{.paramsCall}})
}
`
)

// Option is a function that can set an option on the Builder. It returns
// the previous setting as an Option.
type Option func(*Builder) Option

func OptimizeRefExprByIndex(enable bool) Option {
	return func(b *Builder) Option {
		prev := b.IRefEnable
		b.IRefEnable = enable
		return OptimizeRefExprByIndex(prev)
	}
}

func GrammarOnly(enable bool) Option {
	return func(b *Builder) Option {
		prev := b.GrammarOnly
		b.GrammarOnly = enable
		return GrammarOnly(prev)
	}
}

func RunFuncPrefix(value string) Option {
	return func(b *Builder) Option {
		prev := b.FuncPrefix
		b.FuncPrefix = value
		return RunFuncPrefix(prev)
	}
}

func GrammarName(value string) Option {
	return func(b *Builder) Option {
		prev := b.GrammarName
		b.GrammarName = value
		return GrammarName(prev)
	}
}

// ReceiverName returns an option that specifies the receiver ExprType to
// use for the current struct (which is the struct on which all code blocks
// except the initializer are generated).
func ReceiverName(nm string) Option {
	return func(b *Builder) Option {
		prev := b.RecvName
		b.RecvName = nm
		return ReceiverName(prev)
	}
}

// Optimize returns an option that specifies the Optimize option
// If Optimize is true, the Debug and Memoize code is completely
// removed from the resulting parser
func Optimize(optimize bool) Option {
	return func(b *Builder) Option {
		prev := b.Optimize
		b.Optimize = optimize
		return Optimize(prev)
	}
}

// Nolint returns an option that specifies the Nolint option
// If Nolint is true, special '// Nolint: ...' comments are added
// to the generated parser to suppress warnings by gometalinter or golangci-lint.
func Nolint(nolint bool) Option {
	return func(b *Builder) Option {
		prev := b.Nolint
		b.Nolint = nolint
		return Optimize(prev)
	}
}

// BuildParser builds the PEG parser using the provider grammar. The code is
// written to the specified W.
func BuildParser(w io.Writer, g *ast.Grammar, opts ...Option) error {
	b := &Builder{W: w, RecvName: "c", Target: "go"}
	b.Init()
	b.SetOptions(opts)
	return b.BuildParser(g)
}

type Builder struct {
	W   io.Writer
	Err error

	// options
	RecvName          string
	Optimize          bool
	Nolint            bool
	SetRulePos        bool
	HaveLeftRecursion bool

	RuleName  string
	ExprIndex int
	ArgsStack [][]string

	Target     string
	RangeTable bool
	GrammarMap bool
	Entrypoint string

	IRefEnable     bool
	IRefCodeEnable bool

	FuncPrefix  string
	GrammarName string
	GrammarOnly bool

	RuleName2Index map[string]*ExprInfo

	Shims       OverrideShims
	GetExprInfo func(expr ast.Expression) *ExprInfo

	CallCodeFuncTemplate string
	CallPredFuncTemplate string
}

func GetExprInfo(expr ast.Expression) *ExprInfo {
	switch expr.(type) {
	case *ast.ActionExpr:
		return &ExprInfo{ExprType: "actionExpr"}
	case *ast.AndCodeExpr:
		return &ExprInfo{ExprType: "andCodeExpr"}
	case *ast.AndExpr:
		return &ExprInfo{ExprType: "andExpr"}
	case *ast.AnyMatcher:
		return &ExprInfo{ExprType: "anyMatcher"}
	case *ast.CharClassMatcher:
		return &ExprInfo{ExprType: "charClassMatcher"}
	case *ast.ChoiceExpr:
		return &ExprInfo{ExprType: "choiceExpr"}
	case *ast.LabeledExpr:
		return &ExprInfo{ExprType: "labeledExpr"}
	case *ast.LitMatcher:
		return &ExprInfo{ExprType: "litMatcher"}
	case *ast.NotCodeExpr:
		return &ExprInfo{ExprType: "notCodeExpr"}
	case *ast.NotExpr:
		return &ExprInfo{ExprType: "notExpr"}
	case *ast.OneOrMoreExpr:
		return &ExprInfo{ExprType: "oneOrMoreExpr"}
	case *ast.RecoveryExpr:
		return &ExprInfo{ExprType: "recoveryExpr"}
	case *ast.RuleRefExpr:
		return &ExprInfo{ExprType: "ruleRefExpr"}
	case *ast.SeqExpr:
		return &ExprInfo{ExprType: "seqExpr"}
	case *ast.CodeExpr:
		return &ExprInfo{ExprType: "codeExpr"}
	case *ast.ThrowExpr:
		return &ExprInfo{ExprType: "throwExpr"}
	case *ast.ZeroOrMoreExpr:
		return &ExprInfo{ExprType: "zeroOrMoreExpr"}
	case *ast.ZeroOrOneExpr:
		return &ExprInfo{ExprType: "zeroOrOneExpr"}
	default:
		return nil
	}
}

func (b *Builder) SetOptions(opts []Option) {
	for _, opt := range opts {
		opt(b)
	}
}

type RuleLabelCheck struct {
	IsLabelExists bool
}

func (r *RuleLabelCheck) Visit(expr ast.Expression) ast.Visitor {
	if _, ok := expr.(*ast.RuleRefExpr); ok {
		return nil
	}

	if _, ok := expr.(*ast.LabeledExpr); ok {
		r.IsLabelExists = true
		return nil
	}

	return r
}

func (b *Builder) BuildParser(grammar *ast.Grammar) error {
	for index, rule := range grammar.Rules {
		r := &RuleLabelCheck{}
		ast.Walk(r, rule.Expr)
		grammar.Rules[index].IsLabelExists = r.IsLabelExists
	}

	haveLeftRecursion, err := PrepareGrammar(grammar)
	if err != nil {
		return fmt.Errorf("incorrect grammar: %W", err)
	}
	if haveLeftRecursion {
		return fmt.Errorf("incorrect grammar: %W", ErrHaveLeftRecursion)
	}
	b.HaveLeftRecursion = haveLeftRecursion

	b.writeInit(grammar.Init)
	if !b.GrammarMap {
		b.writeGrammar(grammar)
	} else {
		b.writeGrammar2(grammar)
	}
	for _, rule := range grammar.Rules {
		b.writeRuleCode(rule)
	}

	if !b.GrammarOnly {
		b.writeStaticCodeWrap()
	}

	return b.Err
}

func (b *Builder) writeInit(init *ast.CodeBlock) {
	b.Shims.WriteInit(b, init)
}

func (b *Builder) writeGrammar(g *ast.Grammar) {
	b.Shims.WriteGrammar(b, g)
}

func (b *Builder) writeGrammar2(g *ast.Grammar) {
	b.Shims.WriteGrammar2(b, g)
}

func (b *Builder) WriteRulePos(pos ast.Pos) {
	b.Shims.WriteRulePos(b, pos)
}

func (b *Builder) WriteRule(r *ast.Rule) {
	b.Shims.WriteRule(b, r)
}

func (b *Builder) WriteExpr(expr ast.Expression) {
	b.ExprIndex++
	switch expr := expr.(type) {
	case *ast.ActionExpr:
		b.writeActionExpr(expr)
	case *ast.AndCodeExpr:
		b.writeAndCodeExpr(expr)
	case *ast.AndExpr:
		b.writeAndExpr(expr)
	case *ast.AnyMatcher:
		b.writeAnyMatcher(expr)
	case *ast.CharClassMatcher:
		b.writeCharClassMatcher(expr)
	case *ast.ChoiceExpr:
		b.writeChoiceExpr(expr)
	case *ast.LabeledExpr:
		b.writeLabeledExpr(expr)
	case *ast.LitMatcher:
		b.writeLitMatcher(expr)
	case *ast.NotCodeExpr:
		b.writeNotCodeExpr(expr)
	case *ast.NotExpr:
		b.writeNotExpr(expr)
	case *ast.OneOrMoreExpr:
		b.writeOneOrMoreExpr(expr)
	case *ast.RecoveryExpr:
		b.writeRecoveryExpr(expr)
	case *ast.RuleRefExpr:
		b.writeRuleRefExpr(expr)
	case *ast.SeqExpr:
		b.writeSeqExpr(expr)
	case *ast.CodeExpr:
		b.writeCodeExpr(expr)
	case *ast.ThrowExpr:
		b.writeThrowExpr(expr)
	case *ast.ZeroOrMoreExpr:
		b.writeZeroOrMoreExpr(expr)
	case *ast.ZeroOrOneExpr:
		b.writeZeroOrOneExpr(expr)
	default:
		b.Err = fmt.Errorf("Builder: unknown expression type %T", expr)
	}
}

func (b *Builder) writeAndExpr(and *ast.AndExpr) {
	b.Shims.WriteAndExpr(b, and)
}

func (b *Builder) writeAnyMatcher(any *ast.AnyMatcher) {
	b.Shims.WriteAnyMatcher(b, any)
}

func (b *Builder) writeActionExpr(act *ast.ActionExpr) {
	b.Shims.WriteActionExpr(b, act)
}

func (b *Builder) writeAndCodeExpr(and *ast.AndCodeExpr) {
	b.Shims.WriteAndCodeExpr(b, and)
}

func (b *Builder) writeCharClassMatcher(ch *ast.CharClassMatcher) {
	b.Shims.WriteCharClassMatcher(b, ch)
}

func (b *Builder) writeCodeExpr(state *ast.CodeExpr) {
	b.Shims.WriteCodeExpr(b, state)
}

func (b *Builder) writeChoiceExpr(ch *ast.ChoiceExpr) {
	b.Shims.WriteChoiceExpr(b, ch)
}

func (b *Builder) writeLabeledExpr(lab *ast.LabeledExpr) {
	b.Shims.WriteLabeledExpr(b, lab)
}

func (b *Builder) writeLitMatcher(lit *ast.LitMatcher) {
	b.Shims.WriteLitMatcher(b, lit)
}

func (b *Builder) writeNotCodeExpr(not *ast.NotCodeExpr) {
	b.Shims.WriteNotCodeExpr(b, not)
}

func (b *Builder) writeNotExpr(not *ast.NotExpr) {
	b.Shims.WriteNotExpr(b, not)
}

func (b *Builder) writeOneOrMoreExpr(one *ast.OneOrMoreExpr) {
	b.Shims.WriteOneOrMoreExpr(b, one)
}

func (b *Builder) writeRecoveryExpr(recover *ast.RecoveryExpr) {
	b.Shims.WriteRecoveryExpr(b, recover)
}

func (b *Builder) writeRuleRefExpr(ref *ast.RuleRefExpr) {
	b.Shims.WriteRuleRefExpr(b, ref)
}

func (b *Builder) writeSeqExpr(seq *ast.SeqExpr) {
	b.Shims.WriteSeqExpr(b, seq)
}

func (b *Builder) writeThrowExpr(throw *ast.ThrowExpr) {
	b.Shims.WriteThrowExpr(b, throw)
}

func (b *Builder) writeZeroOrMoreExpr(zero *ast.ZeroOrMoreExpr) {
	b.Shims.WriteZeroOrMoreExpr(b, zero)
}

func (b *Builder) writeZeroOrOneExpr(zero *ast.ZeroOrOneExpr) {
	b.Shims.WriteZeroOrOneExpr(b, zero)
}

func (b *Builder) writeRuleCode(rule *ast.Rule) {
	if rule == nil || rule.Name == nil {
		return
	}

	// keep trace of the current rule, as the code blocks are created
	// in functions named "on<RuleName><#ExprIndex>".
	b.RuleName = rule.Name.Val
	b.pushArgsSet()
	b.writeExprCode(rule.Expr)
	b.popArgsSet()
}

func (b *Builder) pushArgsSet() {
	b.ArgsStack = append(b.ArgsStack, nil)
}

func (b *Builder) popArgsSet() {
	b.ArgsStack = b.ArgsStack[:len(b.ArgsStack)-1]
}

func (b *Builder) addArg(arg *ast.Identifier) {
	if arg == nil {
		return
	}
	ix := len(b.ArgsStack) - 1
	b.ArgsStack[ix] = append(b.ArgsStack[ix], arg.Val)
}

func (b *Builder) writeExprCode(expr ast.Expression) {
	switch expr := expr.(type) {
	case *ast.ActionExpr:
		b.writeExprCode(expr.Expr)
		b.writeActionExprCode(expr)

	case *ast.AndCodeExpr:
		b.writeAndCodeExprCode(expr)

	case *ast.LabeledExpr:
		b.addArg(expr.Label)
		b.pushArgsSet()
		b.writeExprCode(expr.Expr)
		b.popArgsSet()

	case *ast.NotCodeExpr:
		b.writeNotCodeExprCode(expr)

	case *ast.AndExpr:
		b.pushArgsSet()
		b.writeExprCode(expr.Expr)
		b.popArgsSet()

	case *ast.ChoiceExpr:
		for _, alt := range expr.Alternatives {
			b.pushArgsSet()
			b.writeExprCode(alt)
			b.popArgsSet()
		}

	case *ast.NotExpr:
		b.pushArgsSet()
		b.writeExprCode(expr.Expr)
		b.popArgsSet()

	case *ast.OneOrMoreExpr:
		b.pushArgsSet()
		b.writeExprCode(expr.Expr)
		b.popArgsSet()

	case *ast.RecoveryExpr:
		b.pushArgsSet()
		b.writeExprCode(expr.Expr)
		b.writeExprCode(expr.RecoverExpr)
		b.popArgsSet()

	case *ast.SeqExpr:
		for _, sub := range expr.Exprs {
			b.writeExprCode(sub)
		}

	case *ast.CodeExpr:
		b.writeCodeExprCode(expr)

	case *ast.ZeroOrMoreExpr:
		b.pushArgsSet()
		b.writeExprCode(expr.Expr)
		b.popArgsSet()

	case *ast.ZeroOrOneExpr:
		b.pushArgsSet()
		b.writeExprCode(expr.Expr)
		b.popArgsSet()
	}
}

func (b *Builder) writeActionExprCode(act *ast.ActionExpr) {
	if act == nil {
		return
	}
	if act.FuncIx > 0 {
		b.writeFunc(act.FuncIx, act.Code, b.CallCodeFuncTemplate)
		act.FuncIx = 0 // already rendered, prevent duplicates
	}
}

func (b *Builder) writeAndCodeExprCode(and *ast.AndCodeExpr) {
	if and == nil {
		return
	}
	if and.FuncIx > 0 {
		b.writeFunc(and.FuncIx, and.Code, b.CallPredFuncTemplate)
		and.FuncIx = 0 // already rendered, prevent duplicates
	}
}

func (b *Builder) writeNotCodeExprCode(not *ast.NotCodeExpr) {
	if not == nil {
		return
	}
	if not.FuncIx > 0 {
		b.writeFunc(not.FuncIx, not.Code, b.CallPredFuncTemplate)
		not.FuncIx = 0 // already rendered, prevent duplicates
	}
}

func (b *Builder) writeCodeExprCode(code *ast.CodeExpr) {
	if code == nil {
		return
	}
	if code.FuncIx > 0 {
		b.writeFunc(code.FuncIx, code.Code, b.CallCodeFuncTemplate)
		code.FuncIx = 0 // already rendered, prevent duplicates
	}
}

func StringArrayUniq(items []string) []string {
	var newArray []string
	m := map[string]bool{}
	for _, i := range items {
		if !m[i] {
			m[i] = true
			newArray = append(newArray, i)
		}
	}
	return newArray
}

func (b *Builder) writeFunc(funcIx int, code *ast.CodeBlock, funcTpl string) {
	b.Shims.WriteFunc(b, funcIx, code, funcTpl)
}

func (b *Builder) writeStaticCodeWrap() {
	b.Shims.WriteStaticCodeWrap(b)
}

func (b *Builder) WriteStaticCode(code string) {
	buffer := bytes.NewBufferString("")
	params := struct {
		Optimize       bool
		Nolint         bool
		SetRulePos     bool
		Entrypoint     string
		GrammarMap     bool
		IRefEnable     bool
		IRefCodeEnable bool
		NeedExprWrap   bool
		ParseExprName  string
		GrammarVarName string
	}{
		Optimize:       b.Optimize,
		Nolint:         b.Nolint,
		SetRulePos:     b.SetRulePos,
		Entrypoint:     b.Entrypoint,
		GrammarMap:     b.GrammarMap,
		IRefEnable:     b.IRefEnable,
		IRefCodeEnable: b.IRefCodeEnable,
		NeedExprWrap:   !b.Optimize || b.HaveLeftRecursion,
		ParseExprName:  "parseExpr",
		GrammarVarName: b.GrammarName,
	}
	if !params.NeedExprWrap {
		params.ParseExprName = "parseExprWrap"
	}
	t := template.Must(template.New("static_code").Parse(code))

	err := t.Execute(buffer, params)
	if err != nil {
		// This is very unlikely to ever happen
		panic("executing template: " + err.Error())
	}

	// Clean the ==template== comments from the generated parser
	lines := strings.Split(buffer.String(), "\n")
	buffer.Reset()
	re := regexp.MustCompile(`^\s*//\s*(==template==\s*)+$`)
	reLineEnd := regexp.MustCompile(`//\s*==template==\s*$`)
	for _, line := range lines {
		if !re.MatchString(line) {
			line = reLineEnd.ReplaceAllString(line, "")
			_, err := buffer.WriteString(line + "\n")
			if err != nil {
				// This is very unlikely to ever happen
				panic("unable to write to byte buffer: " + err.Error())
			}
		}
	}

	b.Writeln(buffer.String())
	// if b.RangeTable {
	// 	b.Writeln(rangeTable0)
	// }
}

func (b *Builder) FuncName(ix int) string {
	return b.Shims.FuncName(b, ix)
}

func (b *Builder) WriteArray(typeName string, newline bool, inside func()) {
	b.Shims.WriteArray(b, typeName, newline, inside)
}

func (b *Builder) WriteExprBlock(typeName string, newline bool, inside func()) {
	b.Shims.WriteExprBlock(b, typeName, newline, inside)
}

func (b *Builder) WriteNilLine() {
	b.Shims.WriteNilLine(b) // b.WriteNilLine()
}

func (b *Builder) Writef(f string, args ...any) {
	if b.Err == nil {
		_, b.Err = fmt.Fprintf(b.W, f, args...)
	}
}

func (b *Builder) Writelnf(f string, args ...any) {
	b.Writef(f+"\n", args...)
}

func (b *Builder) Writeln(f string) {
	if b.Err == nil {
		_, b.Err = fmt.Fprint(b.W, f+"\n")
	}
}

type OverrideShims struct {
	WriteInit             func(b *Builder, init *ast.CodeBlock)
	WriteGrammar          func(b *Builder, g *ast.Grammar)
	WriteGrammar2         func(b *Builder, g *ast.Grammar)
	WriteRule             func(b *Builder, r *ast.Rule)
	WriteAndExpr          func(b *Builder, and *ast.AndExpr)
	WriteAnyMatcher       func(b *Builder, any *ast.AnyMatcher)
	WriteActionExpr       func(b *Builder, act *ast.ActionExpr)
	WriteAndCodeExpr      func(b *Builder, and *ast.AndCodeExpr)
	WriteCharClassMatcher func(b *Builder, ch *ast.CharClassMatcher)
	WriteCodeExpr         func(b *Builder, state *ast.CodeExpr)
	WriteChoiceExpr       func(b *Builder, ch *ast.ChoiceExpr)
	WriteLabeledExpr      func(b *Builder, lab *ast.LabeledExpr)
	WriteLitMatcher       func(b *Builder, lit *ast.LitMatcher)
	WriteNotCodeExpr      func(b *Builder, not *ast.NotCodeExpr)
	WriteNotExpr          func(b *Builder, not *ast.NotExpr)
	WriteOneOrMoreExpr    func(b *Builder, one *ast.OneOrMoreExpr)
	WriteRecoveryExpr     func(b *Builder, recover *ast.RecoveryExpr)
	WriteRuleRefExpr      func(b *Builder, ref *ast.RuleRefExpr)
	WriteSeqExpr          func(b *Builder, seq *ast.SeqExpr)
	WriteThrowExpr        func(b *Builder, throw *ast.ThrowExpr)
	WriteZeroOrMoreExpr   func(b *Builder, zero *ast.ZeroOrMoreExpr)
	WriteZeroOrOneExpr    func(b *Builder, zero *ast.ZeroOrOneExpr)
	WriteFunc             func(b *Builder, funcIx int, code *ast.CodeBlock, funcTpl string)

	FuncName func(b *Builder, ix int) string

	// These functions must be overloaded for another language target
	WriteRulePos        func(b *Builder, pos ast.Pos)
	WriteStaticCodeWrap func(b *Builder)
	WriteNilLine        func(b *Builder)
	WriteArray          func(b *Builder, typeName string, newline bool, inside func())
	WriteExprBlock      func(b *Builder, name string, newline bool, inside func())
}

func (b *Builder) Init() {
	b.GetExprInfo = GetExprInfo
	b.CallCodeFuncTemplate = callCodeFuncTemplate
	b.CallPredFuncTemplate = callPredFuncTemplate

	b.Shims.WriteInit = func(b *Builder, init *ast.CodeBlock) {
		if init == nil {
			return
		}

		// remove opening and closing braces
		val := codeGeneratedComment + b.TemplateRender(init.Val[1:len(init.Val)-1], false)
		b.Writelnf("%s", val)
	}

	b.Shims.WriteGrammar = func(b *Builder, g *ast.Grammar) {
		// transform the ast grammar to the self-contained, no dependency version
		// of the parser-generator grammar.

		m := map[string]*ExprInfo{}

		for index, r := range g.Rules {
			info := b.GetExprInfo(r.Expr)
			info.Index = index
			m[r.Name.Val] = info
		}
		b.RuleName2Index = m

		b.Writelnf("var %s = &grammar {", b.GrammarName)
		b.Writelnf("\trules: []*rule{")
		for _, r := range g.Rules {
			b.WriteRule(r)
		}
		b.Writelnf("\t},")
		b.Writelnf("}")
	}

	b.Shims.WriteGrammar2 = func(b *Builder, g *ast.Grammar) {
		// transform the ast grammar to the self-contained, no dependency version
		// of the parser-generator grammar.
		b.Writelnf("var g = map[string]*rule {")
		for _, r := range g.Rules {
			b.WriteRule(r)
		}
		b.Writelnf("}")
	}

	b.Shims.WriteRule = func(b *Builder, r *ast.Rule) {
		if r == nil || r.Name == nil {
			return
		}

		b.ExprIndex = 0
		b.RuleName = r.Name.Val

		if b.Entrypoint == "" {
			b.Entrypoint = r.Name.Val
		}

		if b.GrammarMap {
			b.Writelnf("%q: {", r.Name.Val)
		} else {
			b.Writelnf("{")
		}
		b.Writelnf("\tname: %q,", r.Name.Val)
		if r.DisplayName != nil && r.DisplayName.Val != "" {
			b.Writelnf("\tdisplayName: %q,", r.DisplayName.Val)
		}
		if r.IsLabelExists {
			b.Writelnf("\tvarExists: %t,", r.IsLabelExists)
		}
		b.WriteRulePos(r.Pos())
		b.Writef("\texpr: ")
		b.WriteExpr(r.Expr)
		if b.HaveLeftRecursion {
			b.Writelnf("\tleader: %t,", r.Leader)
			b.Writelnf("\tleftRecursive: %t,", r.LeftRecursive)
		}
		b.Writelnf("},")
	}

	b.Shims.WriteAndExpr = func(b *Builder, and *ast.AndExpr) {
		if and == nil {
			b.WriteNilLine()
			return
		}
		exprName := "andExpr"
		if and.Logical {
			exprName = "andLogicalExpr"
		}
		// &andLogicalExpr{
		b.Shims.WriteExprBlock(b, exprName, true, func() {
			b.WriteRulePos(and.Pos())
			b.Writef("\texpr: ")
			b.WriteExpr(and.Expr)
		})
	}

	b.Shims.WriteAnyMatcher = func(b *Builder, any *ast.AnyMatcher) {
		if any == nil {
			b.WriteNilLine()
			return
		}

		if b.SetRulePos {
			b.WriteExprBlock("anyMatcher", true, func() {
				pos := any.Pos()
				b.Writelnf("\tline: %d, col: %d, offset: %d,", pos.Line, pos.Col, pos.Off)
			})
		} else {
			// b.Writelnf("&anyMatcher{},")
			b.WriteExprBlock("anyMatcher", false, nil)
		}
	}

	b.Shims.WriteActionExpr = func(b *Builder, act *ast.ActionExpr) {
		if act == nil {
			b.WriteNilLine()
			return
		}
		if act.FuncIx == 0 {
			act.FuncIx = b.ExprIndex
		}
		b.WriteExprBlock("actionExpr", true, func() {
			b.WriteRulePos(act.Pos())
			b.Writelnf("\trun: (*parser).call%s,", b.FuncName(act.FuncIx))
			b.Writef("\texpr: ")
			b.WriteExpr(act.Expr)
		})
	}

	b.Shims.WriteAndCodeExpr = func(b *Builder, and *ast.AndCodeExpr) {
		if and == nil {
			b.WriteNilLine()
			return
		}
		b.WriteExprBlock("andCodeExpr", false, func() {
			pos := and.Pos()
			if and.FuncIx == 0 {
				and.FuncIx = b.ExprIndex
			}
			b.WriteRulePos(pos)
			b.Writef("\trun: (*parser).call%s,", b.FuncName(and.FuncIx))
		})
	}

	b.Shims.WriteCharClassMatcher = func(b *Builder, ch *ast.CharClassMatcher) {
		if ch == nil {
			b.WriteNilLine()
			return
		}
		b.WriteExprBlock("charClassMatcher", true, func() {
			pos := ch.Pos()
			b.WriteRulePos(pos)
			b.Writelnf("\tval: %q,", ch.Val)
			if len(ch.Chars) > 0 {
				b.Writef("\tchars:")
				b.WriteArray("rune", false, func() {
					for _, rn := range ch.Chars {
						if ch.IgnoreCase {
							b.Writef("%q,", unicode.ToLower(rn))
						} else {
							b.Writef("%q,", rn)
						}
					}
				})
			}
			if len(ch.Ranges) > 0 {
				b.Writef("\tranges:")
				b.WriteArray("rune", false, func() {
					for _, rn := range ch.Ranges {
						if ch.IgnoreCase {
							b.Writef("%q,", unicode.ToLower(rn))
						} else {
							b.Writef("%q,", rn)
						}
					}
				})
			}
			if len(ch.UnicodeClasses) > 0 {
				b.RangeTable = true
				b.Writef("\tclasses: ")
				b.WriteArray("*unicode.RangeTable", false, func() {
					for _, cl := range ch.UnicodeClasses {
						// b.Writef("RangeTable(%q),", cl)
						b.Writef("unicode.%s,", cl)
					}
				})
			}
			if ch.IgnoreCase {
				b.Writelnf("\tignoreCase: %t,", ch.IgnoreCase)
			}
			if ch.Inverted {
				b.Writelnf("\tinverted: %t,", ch.Inverted)
			}
		})
	}

	b.Shims.WriteCodeExpr = func(b *Builder, state *ast.CodeExpr) {
		if state == nil {
			b.WriteNilLine()
			return
		}
		b.WriteExprBlock("codeExpr", true, func() {
			pos := state.Pos()
			if state.FuncIx == 0 {
				state.FuncIx = b.ExprIndex
			}
			b.WriteRulePos(pos)
			b.Writelnf("\trun: (*parser).call%s,", b.FuncName(state.FuncIx))
			if state.NotSkip {
				b.Writelnf("\tnotSkip: %v,", state.NotSkip)
			}
		})
	}

	b.Shims.WriteChoiceExpr = func(b *Builder, ch *ast.ChoiceExpr) {
		if ch == nil {
			b.WriteNilLine()
			return
		}
		b.WriteExprBlock("choiceExpr", true, func() {
			pos := ch.Pos()
			b.WriteRulePos(pos)
			if len(ch.Alternatives) > 0 {
				b.Writelnf("\talternatives:")
				b.WriteArray("any", true, func() {
					for _, alt := range ch.Alternatives {
						b.WriteExpr(alt)
					}
				})
			}
		})
	}

	b.Shims.WriteLabeledExpr = func(b *Builder, lab *ast.LabeledExpr) {
		if lab == nil {
			b.WriteNilLine()
			return
		}
		b.WriteExprBlock("labeledExpr", true, func() {
			pos := lab.Pos()
			b.WriteRulePos(pos)
			if lab.Label != nil && lab.Label.Val != "" {
				b.Writelnf("\tlabel: %q,", lab.Label.Val)
			}
			b.Writef("\texpr: ")
			b.WriteExpr(lab.Expr)
			if lab.TextCapture {
				b.Writelnf("\ttextCapture: %v,", lab.TextCapture)
			}
		})
	}

	b.Shims.WriteLitMatcher = func(b *Builder, lit *ast.LitMatcher) {
		if lit == nil {
			b.WriteNilLine()
			return
		}

		writeFunc := b.Writef
		if b.SetRulePos {
			writeFunc = b.Writelnf
		}

		// writeFunc("&litMatcher{")
		b.WriteExprBlock("litMatcher", b.SetRulePos, func() {
			pos := lit.Pos()
			b.WriteRulePos(pos)
			if lit.IgnoreCase {
				writeFunc("\tval: %q,", strings.ToLower(lit.Val))
			} else {
				writeFunc("\tval: %q,", lit.Val)
			}
			if lit.IgnoreCase {
				writeFunc("\tignoreCase: %t,", lit.IgnoreCase)
			}
			ignoreCaseFlag := ""
			if lit.IgnoreCase {
				ignoreCaseFlag = "i"
			}
			writeFunc("\twant: %q,", strconv.Quote(lit.Val)+ignoreCaseFlag)
		})
	}

	b.Shims.WriteNotCodeExpr = func(b *Builder, not *ast.NotCodeExpr) {
		if not == nil {
			b.WriteNilLine()
			return
		}
		b.WriteExprBlock("notCodeExpr", false, func() {
			pos := not.Pos()
			if not.FuncIx == 0 {
				not.FuncIx = b.ExprIndex
			}
			b.WriteRulePos(pos)
			b.Writef("\trun: (*parser).call%s,", b.FuncName(not.FuncIx))
		})
	}

	b.Shims.WriteNotExpr = func(b *Builder, not *ast.NotExpr) {
		if not == nil {
			b.WriteNilLine()
			return
		}
		name := "notExpr"
		if not.Logical {
			name = "notLogicalExpr"
		}

		b.WriteExprBlock(name, true, func() {
			pos := not.Pos()
			b.WriteRulePos(pos)
			b.Writef("\texpr: ")
			b.WriteExpr(not.Expr)
		})
	}

	b.Shims.WriteOneOrMoreExpr = func(b *Builder, one *ast.OneOrMoreExpr) {
		if one == nil {
			b.WriteNilLine()
			return
		}

		b.WriteExprBlock("oneOrMoreExpr", true, func() {
			pos := one.Pos()
			b.WriteRulePos(pos)
			b.Writef("\texpr: ")
			b.WriteExpr(one.Expr)
		})
	}

	b.Shims.WriteRecoveryExpr = func(b *Builder, recover *ast.RecoveryExpr) {
		if recover == nil {
			b.WriteNilLine()
			return
		}
		b.WriteExprBlock("recoveryExpr", true, func() {
			pos := recover.Pos()
			b.WriteRulePos(pos)

			b.Writef("\texpr: ")
			b.WriteExpr(recover.Expr)
			b.Writef("\trecoverExpr: ")
			b.WriteExpr(recover.RecoverExpr)

			b.Writelnf("\tfailureLabel: ")
			// []string{ ... }
			b.WriteArray("string", true, func() {
				for _, label := range recover.Labels {
					b.Writelnf("%q,", label)
				}
			})
		})
	}

	b.Shims.WriteRuleRefExpr = func(b *Builder, ref *ast.RuleRefExpr) {
		if ref == nil {
			b.WriteNilLine()
			return
		}
		if b.IRefEnable {
			name := "ruleIRefExpr"
			if b.IRefCodeEnable {
				name = "ruleIRefExprX"
			}
			b.WriteExprBlock(name, false, func() {
				pos := ref.Pos()
				b.WriteRulePos(pos)
				if ref.Name != nil && ref.Name.Val != "" {
					info := b.RuleName2Index[ref.Name.Val]
					b.Writef("\tindex: %d /* %s */", info.Index, ref.Name.Val)

					if b.IRefCodeEnable {
						exprType := info.ExprType
						if exprType == "ruleRefExpr" {
							exprType = "ruleIRefExprX"
						}
						parseFnName := "parse" + strings.ToUpper(exprType[:1]) + exprType[1:]
						b.Writef(", call: func(p*parser, expr any) (any, bool) { return p.%s(expr.(*rule).expr.(*%s)) }", parseFnName, exprType)
					}
				}
			})
		} else {
			b.WriteExprBlock("ruleRefExpr", false, func() {
				pos := ref.Pos()
				b.WriteRulePos(pos)
				if ref.Name != nil && ref.Name.Val != "" {
					b.Writef("\tname: %q,", ref.Name.Val)
				}
			})
		}
	}

	b.Shims.WriteSeqExpr = func(b *Builder, seq *ast.SeqExpr) {
		if seq == nil {
			b.WriteNilLine()
			return
		}
		b.WriteExprBlock("seqExpr", true, func() {
			b.WriteRulePos(seq.Pos())
			if len(seq.Exprs) > 0 {
				b.Writef("\texprs: ")
				b.WriteArray("any", true, func() {
					for _, e := range seq.Exprs {
						b.WriteExpr(e)
					}
				})
			}
		})
	}

	b.Shims.WriteThrowExpr = func(b *Builder, throw *ast.ThrowExpr) {
		if throw == nil {
			b.WriteNilLine()
			return
		}
		b.WriteExprBlock("throwExpr", true, func() {
			pos := throw.Pos()
			b.WriteRulePos(pos)
			b.Writelnf("\tlabel: %q,", throw.Label)
		})
	}

	b.Shims.WriteZeroOrMoreExpr = func(b *Builder, zero *ast.ZeroOrMoreExpr) {
		if zero == nil {
			b.WriteNilLine()
			return
		}
		b.WriteExprBlock("zeroOrMoreExpr", true, func() {
			pos := zero.Pos()
			b.WriteRulePos(pos)
			b.Writef("\texpr: ")
			b.WriteExpr(zero.Expr)
		})
	}

	b.Shims.WriteZeroOrOneExpr = func(b *Builder, zero *ast.ZeroOrOneExpr) {
		if zero == nil {
			b.WriteNilLine()
			return
		}

		b.WriteExprBlock("zeroOrOneExpr", true, func() {
			pos := zero.Pos()
			b.WriteRulePos(pos)
			b.Writef("\texpr: ")
			b.WriteExpr(zero.Expr)
		})
	}

	b.Shims.WriteFunc = func(b *Builder, funcIx int, code *ast.CodeBlock, funcTpl string) {
		if code == nil {
			return
		}
		val := b.TemplateRender(strings.TrimSpace(code.Val)[1:len(code.Val)-1], true)
		if len(val) > 0 && val[0] == '\n' {
			val = val[1:]
		}
		if len(val) > 0 && val[len(val)-1] == '\n' {
			val = val[:len(val)-1]
		}
		var args bytes.Buffer
		ix := len(b.ArgsStack) - 1
		argsInfo := StringArrayUniq(b.ArgsStack[ix])
		if ix >= 0 {
			for i, arg := range argsInfo {
				if i > 0 {
					args.WriteString(", ")
				}
				args.WriteString(arg)
			}
		}
		if args.Len() > 0 {
			args.WriteString(" any")
		}

		params := args.String()
		args.Reset()
		if ix >= 0 {
			for i, arg := range argsInfo {
				if i > 0 {
					args.WriteString(", ")
				}
				args.WriteString(fmt.Sprintf(`stack[%q]`, arg))
			}
		}

		b.Writelnf(b.TemplateRenderBase(funcTpl, false, map[string]any{
			"FuncName":   b.FuncName(funcIx),
			"paramsDef":  params,
			"code":       val,
			"paramsCall": args.String(),
			"useStack":   len(argsInfo) > 0,
		}))
	}

	b.Shims.WriteRulePos = func(b *Builder, pos ast.Pos) {
		if b.SetRulePos {
			b.Writelnf("\tpos: position{line: %d, col: %d, offset: %d},", pos.Line, pos.Col, pos.Off)
		}
	}

	b.Shims.WriteNilLine = func(b *Builder) {
		b.Writelnf("nil,")
	}

	b.Shims.WriteStaticCodeWrap = func(b *Builder) {
		b.WriteStaticCode(staticCode)
	}

	b.Shims.FuncName = func(b *Builder, ix int) string {
		return "_on" + b.FuncPrefix + b.RuleName + "_" + strconv.Itoa(ix)
	}

	b.Shims.WriteExprBlock = func(b *Builder, name string, newline bool, inside func()) {
		// &zeroOrMoreExpr{ ... }
		b.Writef("&%s{", name)
		if newline {
			b.Writeln("")
		}
		if inside != nil {
			inside()
		}
		b.Writef("},\n")
	}

	b.Shims.WriteArray = func(b *Builder, typeName string, newline bool, inside func()) {
		// Example: []any{},
		b.Writef("[]%s{", typeName)
		if newline {
			b.Writeln("")
		}
		if inside != nil {
			inside()
		}
		b.Writeln("},")
	}
}
